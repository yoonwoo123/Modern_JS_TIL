# 200726_TIL 소개 ~ 자바스크립트 기초

- Chrome 개발자 도구의 Source 부분을 통한 디버깅하기

- Hello, World!

  - HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용합니다. 스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋습니다.

    스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 [캐시(cache)](https://en.wikipedia.org/wiki/Web_cache)에 저장하기 때문에, 성능상의 이점이 있습니다.

    여러 페이지에서 동일한 스크립트를 사용하는 경우, 브라우저는 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않고 캐시로부터 스크립트를 가져와 사용합니다. 스크립트 파일을 한 번만 다운받으면 되죠.

    이를 통해 트래픽이 절약되고 웹 페이지의 실 속도가 빨라집니다.

  - **`src` 속성이 있으면 태그 내부의 코드는 무시됩니다.**

    <script> 태그는 src 속성과 내부 코드를 동시에 가지지 못합니다.


    다음 코드는 실행되지 않습니다.
    
    ```html
    <script src="file.js">
      alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
    </script>
    ```
    
    따라서 `<script src="…">`로 외부 파일을 연결할지 아니면 `<script>` 태그 내에 코드를 작성할지를 선택해야 합니다.
    
    위의 예시는 스크립트 두 개로 분리하면 정상적으로 실행됩니다.


​    

- 엄격 모드

  - __'use strict'__ 가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.
  - **코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 됩니다. 그런데 아직은 이 둘을 배우지 않았으니 `"use strict"`를 귀한 손님처럼 모시도록 하겠습니다.**

- 자료형

  - `Infinity`는 어떤 숫자보다 큰 특수 값, [무한대(∞)](https://en.wikipedia.org/wiki/Infinity)를 나타냅니다.

    어느 숫자든 0으로 나누면 무한대를 얻을 수 있습니다.

    `Infinity`를 직접 참조할 수도 있습니다.

    ```javascript
    alert( Infinity ); // 무한대
    ```

  - `NaN`은 계산 중에 에러가 발생했다는 것을 나타내주는 값입니다. 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는 데, 이때 `NaN`이 반환됩니다.

  - 말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽지 않습니다. `NaN`을 반환하며 연산이 종료될 뿐입니다.

  - __BigInt__

    `BigInt`형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.

    `BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있습니다.

    ```javascript
    // 끝에 'n'이 붙으면 BigInt형 자료입니다.
    const bigInt = 1234567890123456789012345678901234567890n;
    ```

  - __null__ 값

    자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다릅니다. 다른 언어에선 `null`을 '존재하지 않는 객체에 대한 참조’나 '널 포인터(null pointer)'를 나타낼 때 사용합니다.

    하지만 자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.

    `let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여줍니다.

  - `typeof null`의 결과는 `"object"`입니다. `null`은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨둔 상황입니다. 언어 자체의 오류이므로 `null`이 객체가 아님에 유의하시기 바랍니다.

  - `typeof`는 피연산자가 함수면 `"function"`을 반환합니다. 그러므로 `typeof alert`는 `"function"`을 출력해줍니다. 그런데 '함수’형은 따로 없습니다. 함수는 객체형에 속합니다. 이런 동작 방식이 형식적으론 잘못되긴 했지만, 아주 오래전에 만들어진 규칙이었기 때문에 하위 호완성 유지를 위해 남겨진 상태입니다. 한편, 실무에선 이런 특징이 매우 유용하게 사용되기도 합니다.

- alert, prompt, confirm을 이용한 상호작용

  - 브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.

    ```javascript
    result = prompt(title, [default]);
    ```

    함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.

    - `title`

      사용자에게 보여줄 문자열

    - `default`

      입력 필드의 초깃값(선택값)

  - confirm

    ```javascript
    result = confirm(question);
    ```

    `confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.

    사용자가 확인버튼를 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.

  - 위 함수들은 모두 모달 창을 띄워주는데, 모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단됩니다. 사용자가 창을 닫기 전까진 나머지 페이지와 상호 작용이 불가능합니다.

    지금까지 살펴본 세 함수엔 두 가지 제약사항이 있습니다.

    1. 모달 창의 위치는 브라우저가 결정하는데, 대개 브라우저 중앙에 위치합니다.
    2. 모달 창의 모양은 브라우저에 마다 다릅니다. 개발자는 창의 모양을 수정할 수 없습니다.

- 기본 연산자와 수학

  - ### [ 형 변환](https://ko.javascript.info/operators#ref-697)

    

    중요도: 5

    아래 표현식들의 결과를 예측해 보세요.

    ```javascript
    "" + 1 + 0              // "10"
    "" - 1 + 0 				// "-10"	
    true + false			// true or 1
    6 / "3"					// "2"
    "2" * "3"				// "6"
    4 + 5 + "px"			// "9px"
    "$" + 4 + 5				// "$45"
    "4" - 2					// "2"
    "4px" - 2				// error
    7 / 0					// Infinity
    "  -9  " + 5			// " -9  5"
    "  -9  " - 5			// " -9  -5"
    null + 1				// "error"
    undefined + 1			// 'error'
    " \t \n" - 2			// 'error'
    ```

    ```javascript
    "" + 1 + 0 = "10" // (1)
    "" - 1 + 0 = -1 // (2)
    true + false = 1
    6 / "3" = 2
    "2" * "3" = 6
    4 + 5 + "px" = "9px"
    "$" + 4 + 5 = "$45"
    "4" - 2 = 2
    "4px" - 2 = NaN
    7 / 0 = Infinity
    " -9  " + 5 = " -9  5" // (3)
    " -9  " - 5 = -14 // (4)
    null + 1 = 1 // (5)
    undefined + 1 = NaN // (6)
    " \t \n" - 2 = -2 // (7)
    ```

    1. 피 연산자 중 하나가 문자열인 `"" + 1`에서 `1`은 문자형으로 변환됩니다. 따라서 공백과 문자열 1을 더한, `"" + 1 = "1"`과 같은 효과를 발휘하죠. 그다음 연산 `"1" + 0`에도 같은 규칙이 적용됩니다.
    2. 뺄셈 연산자 `-`는 기타 수학 연산자처럼 숫자형만을 인수로 받습니다. 빈 문자열 `""`는 숫자 `0`으로 변환되기 때문에 결과는 `-1`이 됩니다.
    3. 피 연산자 중 하나가 문자열이므로 숫자 5가 문자열로 변환됩니다.
    4. 뺄셈 연산자는 인수를 숫자형으로 변화시키므로 `" -9 "`는 숫자 `-9`로 변합니다. 앞, 뒤 공백은 제거되죠.
    5. 숫자형으로 변환 시 `null`은 `0`이 됩니다.
    6. `undefined`는 숫자형으로 변환시 `NaN`이 됩니다.
    7. 문자열이 숫자형으로 변할 땐 문자열 앞뒤의 공백이 삭제됩니다. 뺄셈 연산자 앞의 피연산자는 공백을 만드는 문자 `\t`와 `\n`, 그 사이의 “일반적인” 공백으로 구성됩니다. 따라서 `" \t \n"`는 숫자형으로 변환 시 길이가 `0`인 문자열로 취급되어 숫자 `0`이 됩니다.

- 비교 연산자

  - 같지 않음(부등) : `!=`, `!==`

  - 문자열 비교

    - 자바스크립트는 '사전’순으로 문자열을 비교합니다. '사전편집(lexicographical)'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

      ```javascript
      alert( 'Z' > 'A' ); // true
      ```

      **정확히는 사전순이 아니라 유니코드 순입니다.**

      자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.

      차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 대문자 `"A"`와 소문자 `"a"`를 비교했을 때 소문자 `"a"`가 더 큽니다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 이와 관련한 자세한 내용은 [문자열](https://ko.javascript.info/string) 챕터에서 다루도록 하겠습니다.

  - 다른 형을 가진 값 간의 비교

    - 비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.

      예시:

      ```javascript
      alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
      alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
      ```

      불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄집니다.

      예시:

      ```javascript
      alert( true == 1 ); // true
      alert( false == 0 ); // true
      ```

      **흥미로운 상황**

      같이 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있습니다.

      - 동등 비교(`==`) 시 true를 반환함
      - 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함

      예시:

      ```javascript
      let a = 0;
      alert( Boolean(a) ); // false
      
      let b = "0";
      alert( Boolean(b) ); // true
      
      alert(a == b); // true!
      ```

      두 값을 비교했을 때 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있습니다. 자바스크립트의 관점에선 이런 결과가 아주 자연스럽습니다. 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.

      

    ###  null이나 undefined와 비교하기

    `null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생합니다. 일단 몇 가지 규칙을 먼저 살펴본 후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 아래에서 살펴보도록 하겠습니다.

    - 일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교

      두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환됩니다.

      `alert( null === undefined ); // false`

    - 동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교

      동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환됩니다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플’처럼 취급합니다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못하죠. `alert( null == undefined ); // true`

    - 산술 연산자나 기타 비교 연산자 `< > <= >=`를 사용하여 `null`과 `undefined`를 비교

      `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.

    이제 위에서 살펴본 세 가지 규칙들이 어떤 흥미로운 에지 케이스(edge case)를 만들어내는지 알아봅시다. 이후, 어떻게 하면 에지 케이스가 만들어내는 함정에 빠지지 않을 수 있을지에 대해 알아보도록 하겠습니다.

    ### [null vs 0](https://ko.javascript.info/comparison#ref-316)

    `null`과 0을 비교해 봅시다.

    ```javascript
    alert( null > 0 );  // (1) false
    alert( null == 0 ); // (2) false
    alert( null >= 0 ); // (3) true
    ```

    위의 비교 결과는 논리에 맞지 않습니다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있습니다.

    이는 동등 연산자 `==`와 기타 비교 연산자 `> < >= <=`의 동작 방식이 다르기 때문입니다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문입니다.

    그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않습니다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환합니다. 이런 이유 때문에 (2)는 거짓을 반환합니다.

    

  - ### [함정 피하기](https://ko.javascript.info/comparison#ref-318)

    위와 같은 에지 케이스를 왜 살펴보았을까요? 이런 예외적인 경우를 꼭 기억해 놓고 있어야만 할까요? 그렇지는 않습니다. 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해지기 때문에 지금 당장 암기해야 할 필요는 없습니다. 하지만 아래와 같은 방법을 사용해 이런 예외 상황을 미리 예방할 수 있다는 점은 알아두시길 바랍니다.

    일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하시기 바랍니다.

    또한, `undefined`나 `null`이 될 가능성이 있는 변수가 `>= > < <=`의 피연산자가 되지 않도록 주의하시기 바랍니다. 명확한 의도를 갖고 있지 않은 이상 말이죠. 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다.

    

- ### 조건부 연산자 if와 ?

  - 조건부 연산자는 물음표`?`로 표시합니다. 피연산자가 세 개이기 때문에 조건부 연산자를 '삼항(ternary) 연산자’라고 부르는 사람도 있습니다. 참고로, 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일합니다.

    문법:

    ```javascript
    let result = condition ? value1 : value2;
    ```

    평가 대상인 `condition`이 truthy라면 `value1`이, 그렇지 않으면 `value2`가 반환됩니다.

    ```javascript
    let accessAllowed = (age > 18) ? true : false;
    // 동일하게 동작함
    let accessAllowed = age > 18;
    ```



- ### 논리 연산자

  - 아래 예시를 실행하면 두 번째 메시지만 출력됩니다.

    ```javascript
    true || alert("not printed");
    false || alert("printed");
    ```

    첫 번째 줄의 `||` 연산자는 `true`를 만나자마자 평가를 멈추기 때문에 `alert`가 실행되지 않습니다.

    단락 평가는 조건이 truthy일 때만 명령어를 실행하고자 할 때 자주 쓰입니다.

    

  - **`&&`의 우선순위가 `||`보다 높습니다.**

    AND 연산자 `&&`의 우선순위는 OR 연산자 `||`보다 높습니다.

    따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작합니다.

    

  - NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있습니다.

    ```javascript
    alert( !!"non-empty string" ); // true
    alert( !!null ); // false
    ```

    이때, 첫 번째 NOT 연산자는 피연산자로 받은 값을 불린형으로 변환한 후 이 값의 역을 반환하고, 두 번째 NOT 연산자는 첫 번째 NOT 연산자가 반환한 값의 역을 반환합니다. 이렇게 NOT을 연달아 사용하면 특정 값을 불린형으로 변환할 수 있습니다.

    참고로, 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있습니다.

    ```javascript
    alert( Boolean("non-empty string") ); // true
    alert( Boolean(null) ); // false
    ```

    `NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||` 보다 먼저 실행됩니다.

    

- ### null 병합 연산자

  - null 병합 연산자(nullish coalescing operator) `??`를 사용하면 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 짧은 문법으로도 찾을 수 있습니다.

    상황에 따른 `a ?? b`의 평가 결과를 살펴봅시다.

    - `a`가 `null`이나 `undefined`가 아니면 `a`
    - `a`가 `null`이나 `undefined`이면 `b`

    

  - '??'와 '||'의 차이

    null 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보입니다. 실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하죠.

    그런데 두 연산자 사이에는 중요한 차이점이 있습니다.

    - `||`는 첫 번째 *truthy* 값을 반환합니다.
    - `??`는 *값이 정의되어있는* 첫 번째 값을 반환합니다.

    `null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 합니다.

    예시:

    ```javascript
    height = height ?? 100;
    ```

    `height`에 값을 정의하지 않은 상태라면 `height`엔 `100`이 할당됩니다. 그런데 `height`에 `0`이 할당된 상태라면 값이 바뀌지 않고 그대로 남아있습니다.

    이제 `??`와 `||`을 비교해봅시다.

    ```javascript
    let height = 0;
    
    alert(height || 100); // 100
    alert(height ?? 100); // 0
    ```

    `height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리합니다. 높이에 `0`을 할당하는 것과 유사한 유스케이스에선 이처럼 `||`는 부정확한 결과를 일으킬 수 있습니다.

    대신 `height ?? 100`은 `height`가 정확히 `null`이나 `undefined`일때만 `height`에 `100`을 할당합니다.

    

  - '??'의 우선순위

    - `??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있습니다. 안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하는 것이 금지되어 있습니다.

      아래 예시를 실행해봅시다. 문법 에러가 발생합니다.

      ```javascript
      let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
      ```

      이 제약에 대해선 아직 논쟁이 많긴 하지만 어쨌든 이슈가 있어서 명세서에 제약이 추가된 상황입니다.

      에러를 피하려면 괄호를 사용해주세요.

      ```javascript
      let x = (1 && 2) ?? 3; // 제대로 동작합니다.
      alert(x); // 2
      ```

    

- ### while

  - `do...while`

    `do..while` 문법은 조건이 truthy 인지 아닌지에 상관없이, 본문을 **최소한 한번**이라도 실행하고 싶을 때만 사용해야 합니다. 대다수의 상황에선 `do..while`보다 `while(…) {…}`이 적합합니다.

- ### for

  - for문의 구성 요소

    | 구성 요소 |            |                                                              |
    | :-------- | :--------- | :----------------------------------------------------------- |
    | begin     | `i = 0`    | 반복문에 진입할 때 단 한 번 실행됩니다.                      |
    | condition | `i < 3`    | 반복마다 해당 조건이 확인됩니다. false이면 반복문을 멈춥니다. |
    | body      | `alert(i)` | condition이 truthy일 동안 계속해서 실행됩니다.               |
    | step      | `i++`      | 각 반복의 body가 실행된 이후에 실행됩니다.                   |

    __여기서 매우 중요한 점이 step은 body가 실행된 이후에 실행되는 것!! __

    __따라서 step이 i++ 던, ++i 던간에 body가 진행되고 난 후에 더하므로 i의 값은 똑같이 출력된다!!__ 

    단, 함정은 __++i 가 body내부에 있다면 1이 더해진 i+1 부터 출력되고 step이 진행될 것이다.! __

    

- ### break/continue와 레이블

  여러 개의 중첩 반복문을 한 번에 빠져나와야 하는 경우가 종종 생기곤 합니다.

  `i`와 `j`를 반복하면서 프롬프트 창에 `(0,0)`부터 `(2,2)`까지를 구성하는 좌표 `(i, j)`를 입력하게 해주는 예시를 살펴봅시다.

  ```javascript
  for (let i = 0; i < 3; i++) {
  
    for (let j = 0; j < 3; j++) {
  
      let input = prompt(`(${i},${j})의 값`, '');
  
      // 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면 어떻게 해야 할까요?
    }
  }
  
  alert('완료!');
  ```

  사용자가 `Cancel` 버튼을 눌렀을 때 반복문을 중단시킬 방법이 필요합니다.

  `input` 아래에 평범한 `break` 지시자를 사용하면 안쪽에 있는 반복문만 빠져나올 수 있습니다. 이것만으론 충분하지 않습니다(중첩 반복문을 포함한 반복문 두 개 모두를 빠져나와야 하기 때문이죠 – 옮긴이). 이럴 때 레이블을 사용할 수 있습니다.

  *레이블(label)* 은 반복문 앞에 콜론과 함께 쓰이는 식별자입니다.

  ```javascript
  labelName: for (...) {
    ...
  }
  ```

  반복문 안에서 `break <labelName>`문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있습니다.

  ```javascript
                                   outer: for (let i = 0; i < 3; i++) {
  
    for (let j = 0; j < 3; j++) {
  
      let input = prompt(`(${i},${j})의 값`, '');
  
      // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나옵니다.
      if (!input) break outer; // (*)
  
      // 입력받은 값을 가지고 무언가를 함
    }
  }
  alert('완료!');
  ```

  위 예시에서 `break outer`는 `outer`라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해줍니다.

  따라서 제어 흐름이 `(*)`에서 `alert('완료!')`로 바로 바뀝니다.

  레이블을 별도의 줄에 써주는 것도 가능합니다.

  

- [while 반복문의 출력값 예상하기](https://ko.javascript.info/while-for#ref-18) 중요도: 4

- ### [ 소수 출력하기](https://ko.javascript.info/while-for#ref-23)

  

  중요도: 3

  [소수(prime number)](https://ko.wikipedia.org/wiki/소수_(수론))는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수입니다.

  다시 말해서 `1`과 `그 수 자신` 이외의 자연수로는 나눌 수 없는 자연수를 소수라고 부르죠.

  `5`는 `2`나 `3`, `4`로 나눌 수 없기 때문에 소수입니다. `5`를 이들 숫자로 나누면 나머지가 있기 때문이죠.

  **2부터 `n`까지의 숫자 중 소수만 출력해주는 코드를 작성해봅시다.**

  `n = 10`이라면 결과는 `2,3,5,7`이 되어야겠죠.

  주의: 작성한 코드는 임의의 숫자 `n`에 대해 동작해야 합니다.

  해답

  소수를 판단하는 알고리즘은 다양합니다.

  먼저 중첩 반복문을 사용한 알고리즘을 살펴봅시다.

  ```javascript
  범위 내 모든 숫자 i에 대해서 {
    1과 i 사이에 제수가 있는지를 확인
    있으면 => 소수가 아님
    없으면 => 소수이므로 출력해줌
  }
  ```

  레이블을 사용해 위 알고리즘을 구현한 코드는 다음과 같습니다.

  ```javascript
  let n = 10;
  
  nextPrime:
  for (let i = 2; i <= n; i++) { // 각 i에 대하여 반복문을 돌림
  
    for (let j = 2; j < i; j++) { // 제수(나눗수)를 찾음
      if (i % j == 0) continue nextPrime; // 소수가 아니므로 다음 i로 넘어감
    }
  
    alert( i ); // 소수
  }
  ```

  위에서 사용한 알고리즘은 최적화할 부분이 많습니다. 제수를 `2`와 `i`의 제곱근 사이에서 찾으면 좀 더 나아지겠죠. 아주 큰 `n`에 대해서 [이차 체(Quadratic sieve)](https://ko.wikipedia.org/wiki/이차_체)나 [수 체(General number field sieve)](https://en.wikipedia.org/wiki/General_number_field_sieve)와 같이 좀 더 어려운 수학과 복잡한 알고리즘을 이용해 소수 검색 알고리즘을 개선할 수 있을 겁니다.



